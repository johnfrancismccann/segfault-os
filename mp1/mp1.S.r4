
# mp1.S - missile-command version
# Good luck, and have fun!

.data
	
    # Constants for accessing the fields of a struct missile, 
    # struct missile is defined in rtc.h and mp1.h

	NEXT 	  = 0
	X	  = 4
	Y	  = 8
	VX	  = 12
	VY	  = 16
	DEST_X	  = 20
	DEST_Y	  = 24
	EXPLODED  = 28
	C	  = 32

    # Character to draw for an explosion - '@'

	EXPLOSION = 64


# Data shared between this file and rtc.c helper functions

# This '.globl' directive makes these symbols visible externally
.globl mp1_missile_list, base_alive, mp1_score

mp1_missile_list:	.long 0x0	# Head of list pointer
base_alive:		.long 0x0	# Array of 3 bytes, plus a padding byte
mp1_score:		.long 0x0	# Player's current score


# Data private to this  file

base_pic:     	    .string "/^^^\\"	# Picture of a live base
dead_base_pic: 	    .string "xxxxx"	# Picture of a dead base
crosshairs_x:		.long 0x0	# X-position of the crosshairs
crosshairs_y:		.long 0x0	# Y-position of the crosshairs

.text

# void mp1_poke(void);
# You can use this function to write to video memory.
#
# Interface: Register-based arguments (not C-style)
#    Inputs: %cl  - The byte you wish to write
#            %eax - Offset from the start of video memory that you wish
#                   to write to
#   Outputs: Text-mode video screen is written to at location %eax with
#            the byte in %cl
# Registers: Clobbers EDX

mp1_poke:
		movl    vmem_base_addr(,1),%edx
		movb    %cl,(%edx,%eax,1)
		ret

#   ----------------- Exported functions ---------------------

# void mp1_rtc_tasklet(unsigned long garbage);
# Performs three tasks:
#	(1) updates the list of missiles (implement this in update_missiles,
#           below, and call it from here).
#	(2) Redraw the bases - they may have been overwritten with missiles
#	(3) Redraw the crosshairs - it may have been overwritten with missiles
# Inputs   : none
# Outputs  : none
# Registers: Standard C calling convention

.globl mp1_rtc_tasklet
mp1_rtc_tasklet:
		pushl %ebp		# save old frame pointer
		movl %esp, %ebp		# point to a new frame
		call update_missiles
		leave
		ret

# int mp1_ioctl(unsigned long arg, unsigned int cmd)
# The dispatch function for the MP1 ioctls - should use the cmd argument
# and a jumptable to execute one of the specific ioctls implemented below.
# Inputs   : unsigned long arg - parameter to the mp1_ioctl_....
#          : unsigned int cmd  - specifies which mp1_ioctl_... function 
#          :                     to execute
# Outputs  : Returns an integer - depends on which ioctl() function is called
# Registers: Standard C calling convention

.globl mp1_ioctl
mp1_ioctl:
		movl 8(%esp), %eax	# check cmd
		cmpl $0, %eax
		jb invalid		# invalid command
		cmpl $4, %eax
		ja invalid
		jmp *cmd+(,%eax,4)	# jump with jump table
# ---jump table---
cmd:
		.long mp1_ioctl_startgame, mp1_ioctl_addmissile, mp1_ioctl_movexhairs, mp1_ioctl_getstatus, mp1_ioctl_endgame
		ret
invalid:	
		movl $-1, %eax
		ret

# ----------------- Functions private to this file -------------------

update_missiles:
		pushl %ebp		# save old frame pointer
		movl %esp, %ebp		# point to a new frame
		
		leave
		ret

mp1_ioctl_startgame:
		pushl %ebp		# save old frame pointer
		movl %esp, %ebp		# point to a new frame
		movl $40, crosshairs_x 		# crosshairs set to
		movl $12, crosshairs_y		# middle of screen
		movl $4368, base_alive	# set bases to alive (x1110)
		leave
		ret

mp1_ioctl_addmissile:
		pushl %ebp			# save old frame pointer
		movl %esp, %ebp			# point to a new frame
		movl mp1_missile_list, %edx	# save old missile head in edx
		pushl $33			# push 33 (bytes) on stack
		call mp1_malloc			# for new missile
		cmpl $0, %eax			# check return value for error
		jb addfail			# memory allocation failed
		addl $4, %esp			# pop $33
		movl %eax, %ebx			# save pointer to new missile in ebx
		pushl $33			# push 'n'
		pushl 4(%esp)			# push user_missile pointer as 'from'
		pushl %eax			# push return pointer from malloc as 'to'
		call mp1_copy_from_user
		cmpl $0, %eax			# check return value for error
		jne addfail			# error if return value != 0
		movl %ebx, mp1_missile_list	# have list point to new missile
		movl %edx, (%ebx)		# set 'next' of new missile
		movl $0, %eax			# return 0 if success
		leave
		ret
addfail:
		pushl %eax			# push malloc'ed pointer
		call mp1_free
		movl $-1, %eax			# -1 return value if fail
		leave
		ret

mp1_ioctl_movexhairs:
		pushl %ebp		# save old frame pointer
		movl %esp, %ebp		# point to a new frame

		leave
		ret

mp1_ioctl_getstatus:
		pushl %ebp		# save old frame pointer
		movl %esp, %ebp		# point to a new frame

		leave
		ret

mp1_ioctl_endgame:
		pushl %ebp		# save old frame pointer
		movl %esp, %ebp		# point to a new frame
		
		leave
		ret
